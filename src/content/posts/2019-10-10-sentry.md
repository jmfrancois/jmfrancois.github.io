---
title:  "Sentry: De l'aveuglement à la visibilité - Gestion des erreurs JavaScript dans les SPA"
categories: ["fr"]
tags: ["Talend", "JavaScript", "Sentry", "SPA", "Monitoring"]
date: 2019-10-10
---

Pendant longtemps, chez Talend, nous avions un problème récurrent : des tickets Jira s'accumulaient avec des titres comme "Page blanche", "L'app ne charge pas", "Ça crash sur Chrome". Impossible de reproduire, aucun message d'erreur. Bienvenue dans le monde des Single Page Applications. Et comment j'ai convaincu l'entreprise d'adopter Sentry pour y voir clair.

## Le problème : L'aveuglement des SPA

### Les tickets mystérieux

Les Single Page Applications (SPA) sont magnifiques : chargement instantané, pas de rafraîchissement de page, expérience fluide. Mais elles apportent un cauchemar pour le debugging : **on ne voit rien**.

Voici un ticket typique :

> **Titre :** "App crash au démarrage"
> **Description :** "Mon collègue a lancé l'app ce matin et elle affichait une page blanche. Quand il l'a relancée, ça a marché. Ça reprend aléatoirement."
> **Environnement :** "Chrome, Windows 10"
> **Steps to reproduce :** "On sait pas"

Comment débugger sans erreur ? Comment reproduire un bug qui disparaît au rechargement ?

### L'impact sur l'expérience client

Chez Talend, nous avions une relation complexe avec nos clients. Nos produits sont critiques - des outils d'intégration de données, de migration, d'orchestration. Une "page blanche" signifie que le client ne peut pas travailler.

Mais le pire, c'est que **nous ne saurions jamais combien de clients étaient affectés**. Nous n'avions que les tickets manuels. Combien d'utilisateurs ont juste fermé l'onglet sans signaler le problème ? Combien ont attendu une heure que ça se règle tout seul ?

### Les défis spécifiques des SPA

Les SPA ont des caractéristiques qui rendent le debugging particulièrement difficile :

1. **JavaScript asynchrone** : Les erreurs peuvent arriver dans n'importe quel callback, Promise, ou event listener
2. **Pas de logs côté serveur** : L'erreur arrive dans le navigateur du client
3. **Code bundlé et minifié** : Les stack traces sont illisibles
4. **Source maps** : Nécessaires pour avoir des stack traces lisibles
5. **Erreurs réseau** : Fetch échoue silencieusement si pas traitée
6. **État global complexe** : Impossible de savoir quel state a causé le crash

## La quête d'une solution

C'est là que j'ai découvert **Sentry**.

Sentry est une plateforme de monitoring d'erreurs qui fait essentiellement ceci :
1. Capture chaque erreur qui se produit dans votre application
2. La contextualize avec les informations disponibles (navigateur, version, user, etc.)
3. Vous l'envoie en temps réel
4. Vous permet d'analyser et de trier les erreurs

Révolutionnaire ? Pour nous, oui.

## Convaincre l'entreprise

Pousser l'adoption d'un nouvel outil n'est jamais facile. J'ai dû présenter plusieurs angles d'attaque.

### 1. Le coût humain

Nous perdions énormément de temps à essayer de reproduire des bugs non reproductibles. Un ticket "page blanche" pouvait occuper un développeur une journée entière pour finalement être fermé "won't fix" faute de reproduction.

Avec Sentry, chaque occurrence du bug est enregistrée avec :
- **Stack trace complet** : Exactement où le code a échoué
- **Breadcrumbs** : L'historique des actions de l'utilisateur avant le crash
- **Contexte** : Navigateur, version, résolution d'écran, etc.

### 2. La relation client

C'était mon argument majeur. Quand un client signalait un problème :

**Avant Sentry :**
> "Merci de votre signalement. Pouvez-vous le reproduire ? Avez-vous les étapes exactes ? Une vidéo ? La console du navigateur ?"
> (Le client ne sait généralement pas ce qu'est la console)
> "Nous ne réussissons pas à reproduire. Pouvez-vous essayer à nouveau ?"

**Avec Sentry :**
> Client signale : "L'app affiche une page blanche"
> On regarde Sentry : "Ah, c'est une erreur dans le module de chargement des données qui timeout après 30 secondes. Nous savons exactement ce que c'est. Voici le fix."

### 3. Les métriques

J'ai montré une démo avec un vrai Sentry instance contenant les erreurs d'une de nos applications de test.

Le dashboard montrait :

```
Total events: 1,243 in the last 7 days

Top 5 erreurs :
1. "Cannot read property 'data' of undefined"  - 412 occurrences
2. "Timeout loading configuration"              - 238 occurrences  
3. "Network error: 503"                         - 187 occurrences
4. "Invalid state transition"                   - 152 occurrences
5. "Memory leak in subscription"                - 98 occurrences
```

Soudain, nous avions **de la visibilité**. Nous pouvions prioriser. La première erreur affectait peut-être 80% des tickets de support - on aurait dû la fixer en premier.

### 4. La démo en live

J'ai lancé une application connectée à Sentry, déclenché une erreur, et montré comment elle apparaissait dans Sentry une fraction de seconde plus tard avec toute les informations.

Les yeux des stakeholders ont brillé.

## L'implémentation

L'intégration de Sentry dans une SPA React/Redux est simple.

### Setup basique

```javascript
import * as Sentry from "@sentry/react";

Sentry.init({
  dsn: "https://examplePublicKey@o0.ingest.sentry.io/0",
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
  integrations: [
    new Sentry.Replay({
      maskAllText: true,
      blockAllMedia: true,
    }),
  ],
});

export default Sentry.withProfiler(App);
```

### Capturer les erreurs Redux

```javascript
Sentry.captureException(error, {
  tags: {
    section: 'redux',
    action: action.type,
  },
  contexts: {
    redux: {
      dispatched_action: action,
      previous_state: previousState,
    },
  },
});
```

### Ajouter du contexte utilisateur

```javascript
Sentry.setUser({
  id: user.id,
  email: user.email,
  organization_id: user.organization,
});
```

### Erreurs réseau

```javascript
fetch('/api/data')
  .then(r => r.json())
  .catch(error => {
    Sentry.captureException(error, {
      tags: { type: 'network' },
      contexts: {
        api_call: {
          endpoint: '/api/data',
          method: 'GET',
        },
      },
    });
  });
```

### Source maps en production

C'était critique pour avoir des stack traces lisibles. Nous avons configuré le CI/CD pour uploader les source maps à Sentry à chaque déploiement.

```bash
# Dans le pipeline CI/CD
./node_modules/.bin/sentry-cli releases \
  -o our-org \
  -p our-project \
  files upload-sourcemaps ./dist --ignore node_modules
```

## Les résultats

L'adoption de Sentry a été transformationnelle.

### 1. Temps de debugging réduit de 80%

Un bug qui prenait 4 heures à investiguer peut maintenant être compris en 5 minutes.

**Exemple réel :**

Ticket : "App charge lentement parfois"

Sans Sentry : On mettait des console.log un peu partout, recompilait, attendait qu'un client reproduise, puis on regardait les logs.

Avec Sentry : On voit dans les Performance graphs que certaines requests réseau timeout après 30 secondes, et on peut voir la distribution par navigateur, géolocalisation, etc.

### 2. Réduction des tickets support

Nous avons pu identifier et fixer les 5 bugs les plus courants. Résultat : **40% de réduction des tickets de type "page blanche"** en un mois.

### 3. Proactivité plutôt que réactivité

Au lieu d'attendre les signalements clients, nous repérions les erreurs **avant** que les clients les signalent.

Exemple : Un problème de memory leak sur une certaine version de Chrome qui affectait 2% des utilisateurs. Nous l'avons repéré, fixé, et déployé en 48h sans un seul ticket support.

### 4. Amélioration de la relation client

Nous pouvions répondre aux clients :

> "Merci pour le signalement. Nous avons identifié le problème dans nos logs (une issue avec le timeout du chargement des données). Voici la version corrigée qui sera disponible demain."

Les clients étaient impressionnés par notre réactivité.

### 5. Métriques pour le produit

Sentry nous donnait des données précieuses :
- Quels navigateurs causaient le plus de problèmes ?
- À quelle heure du jour les erreurs étaient-elles pics ?
- Quels features étaient les plus instables ?

Ces informations guidaient nos décisions de développement.

## Le dashboard Sentry en pratique

Voici ce que notre équipe voyait quotidiennement :

```
Today's Overview
├── New Issues: 3
├── Unresolved Issues: 47
├── Total Events: 2,341
│   ├── Errors: 1,823
│   ├── Transactions: 518
│   └── Replay Sessions: 743
│
└── Top Issues This Week:
    1. TypeError: Cannot read property 'map' of undefined
       └── 156 occurrences (-23% from last week) ✓
    
    2. NetworkError: Failed to fetch
       └── 143 occurrences (↑ 15%, needs investigation)
    
    3. RangeError: Invalid array length
       └── 98 occurrences (-45%, fixed in release 2.3.0) ✓
```

## Alerting

Nous avons configuré des alertes intelligentes :

```yaml
Alert 1: "Une nouvelle erreur jamais vue"
  → Alerte immédiate au Slack du team tech

Alert 2: "Une erreur dépasse 100 occurrences en 1 heure"
  → Paging du on-call engineer

Alert 3: "Taux d'erreur augmente de 50% par rapport à la baseline"
  → Investigation automatisée
```

## Session Replay : Le secret weapon

Une des fonctionnalités les plus puissantes de Sentry 3.0+ est la **Session Replay**.

Quand une erreur se produit, Sentry peut enregistrer une vidéo du navigateur (avec les données sensibles masquées).

Exemple :
> Utilisateur signale : "Impossible de soumettre le formulaire"
> On regarde la session replay de Sentry : On voit exactement quels champs ils ont rempli, comment le formulaire a réagi, puis le moment exact du crash.

Cela a sauvé littéralement des dizaines d'heures de debugging.

## Résumé de l'architecture

```
┌──────────────────────────┐
│   Application React      │
│   (avec Sentry SDK)      │
└────────────┬─────────────┘
             │
             │ Erreurs en temps réel
             │
┌────────────▼─────────────┐
│    Sentry Cloud (SaaS)   │
├───────────────────────────┤
│ • Agrégation des erreurs │
│ • Déduplication          │
│ • Source maps processing │
│ • Session Replay         │
│ • Alerting               │
└────────────┬─────────────┘
             │
        ┌────┴─────┬─────────┐
        │           │         │
   ┌────▼──┐  ┌────▼──┐  ┌───▼────┐
   │ Slack │  │ Email │  │ Jira   │
   │ Alerts│  │ Daily │  │ Issues │
   └───────┘  └───────┘  └────────┘
```

## Les pièges à éviter

### 1. Flood de mauvaises erreurs

Sans filtrage, Sentry peut être inondé par :
- Des erreurs de plugins navigateur (adblock, Grammarly, etc.)
- Des erreurs de code tiers
- Des erreurs de développement local

Solution : Mettre en place des rules d'ignoring :

```javascript
Sentry.init({
  ignoreErrors: [
    // Plugin errors
    'top.GLOBALS',
    'chrome-extension://',
    'moz-extension://',
    // Erreurs non pertinentes
    'SecurityError',
  ],
});
```

### 2. Oublier les source maps

Sans source maps, vous voyez :

```
TypeError: a.b is undefined
  at Object.<anonymous> (app.min.js:1:145000)
```

Complètement inutile. Toujours uploader les source maps.

### 3. Ne pas sampler les transactions

Si vous enregistrez **chaque** transaction réseau, Sentry explose rapidement. Limiter à 10-20% en production.

```javascript
Sentry.init({
  tracesSampleRate: 0.1, // 10% des transactions
});
```

## Conclusion

Adopter Sentry a été l'une de meilleures décisions que nous ayons prises en tant que team. Cela nous a permis :

- **De voir les vrais problèmes** plutôt que d'attendre les signalements
- **De réagir rapidement** aux incidents
- **D'améliorer la relation client** avec une support proactive
- **De prioriser intelligemment** les bugfixes

En tant qu'architect, c'était ma responsabilité de pousser pour cette visibilité. Aujourd'hui, je ne peux pas imaginer développer une SPA sans un système de monitoring d'erreurs.

Si vous êtes encore en train de débugger via les tickets de support, je vous supplie d'essayer Sentry. Vous ne regarderez plus jamais votre SPA de la même manière.

---

**Ressources :**
- [Sentry Documentation](https://docs.sentry.io/)
- [React Integration Guide](https://docs.sentry.io/platforms/javascript/guides/react/)
- [Error Handling Best Practices](https://docs.sentry.io/product/error-monitoring/)

